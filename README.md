# Service
Service는 백그라운드에서 오래 실행되는 작업을 수행할 수 있는 애플리케이션 구성 요소이며 사용자 인터페이스를 제공하지 않습니다. 또 다른 애플리케이션 구성 요소가 서비스를 시작할 수 있으며, 이는 사용자가 또 다른 애플리케이션으로 전환하더라도 백그라운드에서 계속해서 실행됩니다. 이외에도, 구성 요소를 서비스에 바인드하여 서비스와 상호작용할 수 있으며, 심지어는 프로세스 간 통신(IPC)도 수행할 수 있습니다. 예를 들어 한 서비스는 네트워크 트랜잭션을 처리하고, 음악을 재생하고 파일 I/O를 수행하거나 콘텐츠 제공자와 상호작용할 수 있으며 이 모든 것을 백그라운드에서 수행할 수 있습니다.

서비스는 본질적으로 두 가지 형식을 취합니다.

**시작됨**

>서비스가 "시작된" 상태가 되려면 애플리케이션 구성 요소(예: 액티비티)가 startService()를 호출하여 시작하면 됩니다. 서비스는 한 번 시작되고 나면 백그라운드에서 무기한으로 실행될 수 있으며, 이는 해당 서비스를 시작한 구성 요소가 소멸되었더라도 무관합니다. 보통, 시작된 서비스는 한 작업을 수행하고 결과를 호출자에게 반환하지 않습니다. 예를 들어 네트워크에서 파일을 다운로드하거나 업로드할 수 있습니다. 작업을 완료하면, 해당 서비스는 알아서 중단되는 것이 정상입니다.


**바인드됨**
>애플리케이션 구성 요소가 bindService()를 호출하여 해당 서비스에 바인드되면 서비스가 "바인드"됩니다. 바인드된 서비스는 클라이언트-서버 인터페이스를 제공하여 구성 요소가 서비스와 상호작용할 수 있도록 해주며, 결과를 가져올 수도 있고 심지어 이와 같은 작업을 여러 프로세스에 걸쳐 프로세스 간 통신(IPC)으로 수행할 수도 있습니다. 바인드된 서비스는 또 다른 애플리케이션 구성 요소가 이에 바인드되어 있는 경우에만 실행됩니다. 여러 개의 구성 요소가 서비스에 한꺼번에 바인드될 수 있지만, 이 모든 것이 바인딩을 해제하면 해당 서비스는 소멸됩니다.


이 문서는 주로 이러한 두 가지 유형의 서비스를 따로따로 논하지만, 서비스는 두 가지 방식 모두로 작동할 수 있습니다. 즉 서비스가 시작될 수도 있고(나아가 무기한으로 실행되고) 바인딩도 허용할 수 있다는 뜻입니다. 이는 그저 두어 가지 콜백 메서드의 구현 여부에 달린 문제입니다. onStartCommand()를 사용하면 구성 요소가 서비스를 시작할 수 있게 허용하고, onBind()를 사용하면 바인딩을 허용합니다.

애플리케이션이 시작되었든, 바인드되었든 아니면 양쪽 모두이든 모든 애플리케이션 구성 요소가 해당 서비스를 사용할 수 있으며(별도의 애플리케이션에서라도), 이는 어느 구성 요소든 액티비티를 사용할 수 있는 것과 같습니다. 이를 Intent로 시작하면 됩니다. 그러나, 매니페스트에서 서비스를 비공개로 선언하고 다른 애플리케이션으로부터의 액세스를 차단할 수도 있습니다. 이것은 매니페스트에서 서비스 선언에 관한 섹션에서 더 자세히 이야기합니다.


##기본사항
서비스를 생성하려면 Service의 서브클래스를 생성해야 합니다(아니면 이의 기존 서브클래스 중 하나). 구현에서는 서비스 수명 주기의 주요 측면을 처리하는 콜백 메서드를 몇 가지 재정의해야 하며 서비스에 바인드할 구성 요소에 대한 메커니즘을 제공해야 합니다(해당되는 경우). 재정의해야 하는 가장 중요한 콜백 메서드는 다음과 같습니다.

**onStartCommand()**
>시스템이 이 메서드를 호출하는 것은 또 다른 구성 요소(예: 액티비티)가 서비스를 시작하도록 요청하는 경우입니다. 이때 startService()를 호출하는 방법을 씁니다. 이 메서드가 실행되면 서비스가 시작되고 백그라운드에서 무기한으로 실행될 수 있습니다. 이것을 구현하면 서비스의 작업이 완료되었을 때 해당 서비스를 중단하는 것은 개발자 본인의 책임이며, 이때 stopSelf() 또는 stopService()를 호출하면 됩니다 (바인딩만 제공하고자 하는 경우, 이 메서드를 구현하지 않아도 됩니다).

**onBind()**
>시스템이 이 메서드를 호출하는 것은 또 다른 구성 요소가 해당 서비스에 바인드되고자 하는 경우 (예를 들어 RPC를 수행하기 위해)입니다. 이때 bindService()를 호출하는 방법을 씁니다. 이 메서드를 구현할 때에는 클라이언트가 서비스와 통신을 주고받기 위해 사용할 인터페이스를 제공해야 합니다. 이때 IBinder를 반환하면 됩니다. 이 메서드는 항상 구현해야 하지만, 바인딩을 허용하지 않고자 하면 null을 반환해야 합니다.

**onCreate()**
>시스템이 이 메서드를 호출하는 것은 서비스가 처음 생성되어 일회성 설정 절차를 수행하는 경우입니다(onStartCommand() 또는 onBind()를 호출하기 전에). 서비스가 이미 실행 중인 경우, 이 메서드는 호출되지 않습니다.

**onDestroy()**
>시스템이 이 메서드를 호출하는 것은 해당 서비스를 더 이상 사용하지 않고 소멸시키는 경우입니다. 서비스에서 이를 구현해야 스레드, 리스너, 수신기 등 모든 리소스를 정리할 수 있습니다. 이는 서비스가 수신하는 마지막 호출입니다.


한 구성 요소가 startService()를 호출하여 서비스를 시작하면(onStartCommand()dp 에 대한 호출 발생), 해당 서비스는 알아서 stopSelf()로 스스로를 중단할 때까지 또는 또 다른 구성 요소가 stopService()를 호출하여 서비스를 중단시킬 때까지 실행 중인 상태로 유지됩니다.

한 구성 요소가 bindService()를 호출하여 서비스를 생성하는 경우(그리고 onStartCommand()를 호출하지 않은 경우), 해당 서비스는 해당 구성 요소가 바인딩된 경우에만 실행됩니다. 서비스가 모든 클라이언트로부터 바인딩 해제되면 시스템이 이를 소멸시킵니다.

Android 시스템이 서비스를 강제 중단시키는 것은 메모리가 부족하여 사용자 포커스를 가진 액티비티를 위해 시스템 리소스를 회복해야만 하는 경우로만 국한됩니다. 해당 서비스가 사용자의 주목을 끌고 있는 액티비티에 바인딩되어 있다면 중단될 가능성이 낮고, 서비스가 포그라운드에서 실행된다고 선언된 경우(나중에 자세히 논함), 거의 절대 중단되지 않습니다. 그렇지 않으면, 서비스가 시작되었고 오랫동안 실행되는 경우 시간이 지나면서 시스템이 백그라운드 작업 목록에서의 이 서비스의 위치를 점점 낮추고 서비스는 중단되기 매우 쉬워집니다. 서비스가 시작되었다면 이를 시스템에 의한 재시작을 정상적으로 처리하도록 디자인해야 합니다. 시스템이 서비스를 중단시키는 경우, 리소스를 다시 사용할 수 있게 되면 가능한 한 빨리 서비스가 다시 시작됩니다(다만 이것은 개발자가 onStartCommand()에서 반환하는 값에 따라 다르며, 이 내용은 나중에 논합니다). 시스템이 서비스를 소멸시킬 수 있는 경우에 대한 자세한 정보는 프로세스와 스레드 문서를 참조하세요.

다음 섹션에서는 각 유형의 서비스를 생성하는 방법과 다른 애플리케이션 구성 요소에서 이를 사용하는 방법을 배우게 됩니다.


###매니페스트에서 서비스 선언

액티비티(및 다른 구성 요소)와 마찬가지로, 서비스는 모두 애플리케이션의 매니페스트 파일에서 선언해야 합니다.

서비스를 선언하려면 <service> 요소를 <application> 요소의 하위로 추가하면 됩니다. 예:
```java
<manifest ... >
  ...
  <application ... >
      <service android:name=".ExampleService" />
      ...
  </application>
</manifest>
```
매니페스트에서 서비스를 선언하는 데 대한 자세한 정보는 <service> 요소 참조를 확인하세요.

<service> 요소에 포함시킬 수 있는 다른 특성도 있습니다. 이들 특성을 포함시키면 서비스를 시작하는 데 필요한 권한과 서비스가 실행되어야 하는 프로세스 등의 속성을 정의할 수 있습니다. android:name 특성이 유일한 필수 특성입니다. 이것은 서비스의 클래스 이름을 나타냅니다. 일단 애플리케이션을 게시하고 나면 이 이름을 변경해서는 안 됩니다. 이름을 변경하면 서비스를 시작하거나 바인드할 명시적 인텐트에 대한 종속성으로 인해 코드를 단절시킬 위험이 있기 때문입니다(블로그 게시물의 바꿀 수 없는 항목을 참조하세요).

앱의 보안을 보장하려면 Service를 시작하거나 바인드할 때 항상 명시적 인텐트를 사용하고 서비스에 대한 인텐트 필터는 선언하지 마세요. 어느 서비스를 시작할지 어느 정도 모호성을 허용하는 것이 중요한 경우, 서비스에 대해 인텐트 필터를 제공하고 구성 요소 이름을 Intent에서 제외시킬 수 있지만, 그러면 해당 인텐트에 대한 패키지를 setPackage()로 설정하여 대상 서비스에 대해 충분한 명확성을 제공해야 합니다.

이외에도 서비스를 본인의 앱에만 사용 가능하도록 보장할 수도 있습니다. 그러려면 android:exported 특성을 포함시키고 이를 "false"로 설정하면 됩니다. 이렇게 하면 다른 앱이 여러분의 서비스를 시작하지 못하도록 효과적으로 방지해주며, 이는 명시적 인텐트를 사용하는 경우에도 문제 없이 적용됩니다.

###시작된 서비스 생성
시작된 서비스란 다른 구성 요소가 startService()를 호출하여 시작하고, 그 결과로 서비스의 onStartCommand() 메서드가 호출되는 경우를 말합니다.

서비스가 시작되면 이를 시작한 구성 요소와 독립된 자신만의 수명 주기를 가지며 해당 서비스는 백그라운드에서 무기한으로 실행될 수 있습니다. 이는 해당 서비스를 시작한 구성 요소가 소멸되었더라도 무관합니다. 따라서, 서비스는 작업이 완료되면 stopSelf()를 호출하여 스스로 알아서 중단하는 것이 정상이며 아니면 다른 구성 요소가 stopService()를 호출하여 중단시킬 수도 있습니다.

애플리케이션 구성 요소(예: 액티비티)가 서비스를 시작하려면 startService()를 호출하고, Intent를 전달하면 됩니다. 이것은 서비스를 지정하며 이 서비스가 사용할 모든 데이터를 포함합니다. 서비스는 이 Intent를 onStartCommand() 메서드에서 수신합니다.

예를 들어 어느 액티비티가 온라인 데이터베이스에 데이터를 약간 저장해야 한다고 가정합니다. 액티비티가 동반 서비스를 시작하고, 저장할 데이터를 이 서비스에 전달할 수 있습니다. 이때 인텐트를 startService()에 전달하면 됩니다. 서비스는 이 인텐트를 onStartCommand()에서 수신하고, 인터넷에 연결한 다음, 데이터베이스 트랜잭션을 수행합니다. 트랜잭션을 완료하면, 해당 서비스는 알아서 스스로 중단되고 소멸됩니다.


